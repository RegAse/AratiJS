/*
	Stores info about the current view and
	can update the view in-part or fully.
*/
function View(rootElement, rawView, controller) {
	this.raw = rawView;
	this.rootElement = rootElement;
	this.controller = new controller(this);
	this.dict = {};
	this.refs = {};
	this.foreachTemplates = {};

	this.viewElement = document.createElement('div');
	this.viewElement.innerHTML = this.raw;
	this.rootElement.innerHTML = "";
}

View.prototype = {
	/*
		Populates the basic values inside a template
	*/
	populate: function() {
		var view = this.viewElement;
		var queue = []
		for (var i = view.childNodes.length - 1; i >= 0; i--) {
			queue.push(view.childNodes[i]);
		}
		while (queue.length > 0)
		{
			for (var i = queue.length - 1; i >= 0; i--) {
				var element = queue.pop();
				if (element.nodeName != "#text" && element.nodeName != "#comment" && element.children.length == 0 && element.getAttribute("ar-foreach") == null) {
					var html = element.innerHTML;

					if (html != null) {
						
						html = Utility.replaceWithVariables(html, this.controller);

						element.innerHTML = html;

						// Process the attributes on the element.
						for (var i = element.attributes.length - 1; i >= 0; i--) {
							var attribute = element.attributes[i];
							attribute.value = Utility.replaceWithVariables(attribute.value, this.controller);
						}
					}
				}
				else if (element.nodeName != "#text" && element.nodeName != "#comment" && element.getAttribute("ar-foreach") == null) {
					for (var i2 = element.childNodes.length - 1; i2 >= 0; i2--) {
						queue.push(element.childNodes[i2]);
					}
				}
				else if (element.nodeName == "#text" && element.data != null && element.data.trim().length != 0) {
					var tex = element.data;
					var text = Utility.replaceWithVariables(tex, this.controller);
					element.data = text;
				}
			}
		}

		// Adds the element to the view.
		this.rootElement.appendChild(this.viewElement);
	},
	/**
	 * Populates all instances of {{variable}} inside
	 * a HTML element the corresponding variable 
	 * from the context and you can specify a 
	 * priorityContextName, so it will process it
	 * from that name as context[priorityContextName][..][variable[i]]
	 * @param {Element} element
	 * @param {Object} context
	 * @param {String} priorityContextName
	 * @return 
	 */
	populateElement: function(element, context, priorityContextName) {
		if (element.nodeName != "#text") {
			element.innerHTML = Utility.replaceWithVariables(element.innerHTML, this.controller, context, priorityContextName);

			this.populateElementAttributes(element, context, priorityContextName);
		}
		else {
			element.data = Utility.replaceWithVariables(element.data, this.controller, context, priorityContextName);
		}
	},
	/**
	 * Populates all instances of {{variable}} inside 
	 * attributes with the corresponding variable from 
	 * the context and you can specify a 
	 * priorityContextName, so it will process it
	 * from that name as context[priorityContextName][..][variable[i]]
	 * @param {Element} element 
	 * @param {Object} context
	 * @param {String} priorityContextName
	 * @return 
	 */
	populateElementAttributes: function(element, context, priorityContextName) {
		// NEED TO PROCESS ATTRIBUTES
		for (var i = element.attributes.length - 1; i >= 0; i--) {
			var attribute = element.attributes[i];
			attribute.value = Utility.replaceWithVariables(attribute.value, this.controller, context, priorityContextName);
		}
	},
	/**
	 * A parent function for populateElements
	 * @param {Object} elementsObj - object with elements grouped into nonParent and parent elements
	 * @param {Object} context - the context/controller.
	 * @param {String} priorityContextName
	 * @return 
	 */
	populateElements: function(elementsObj, context, priorityContextName) {
		for (var i = elementsObj["nonParentElements"].length - 1; i >= 0; i--) {
			this.populateElement(elementsObj["nonParentElements"][i], context, priorityContextName);
		}

		for (var i2 = elementsObj["parentElements"].length - 1; i2 >= 0; i2--) {
			this.populateElementAttributes(elementsObj["parentElements"][i2], context, priorityContextName);
		}
	},
	/* Removes old elements/text generated by a foreach loop */
	removeOldForeachElements: function(propertyName) {
		for (var i = this.refs[propertyName].length - 1; i >= 0; i--) {
			this.refs[propertyName][i].remove();
		}
	},
	/**
	 * Populates a ar-foreach element with data from the controller/model
	 * @param {Object} eachElement - the element to process.
	 * @param {Object} context - the context/controller/otherContext.
	 * @param {String} controller - the context/controller.
	 * @return 
	 */
	populateForeach: function(eachElement, context, controller) {
		var temp = eachElement.getAttribute("ar-foreach").split(" as ");
		var propertyName = temp[0];
		var as = temp[1];

		console.log("Processing: " + propertyName + " as: " + as);
		if (this.refs[propertyName] != null) {
			this.removeOldForeachElements(propertyName);
		}

		var varia = Utility.resolve(context, propertyName);

		// do this x many times
		for (var x = varia.length - 1; x >= 0; x--) {
			// Clone a html element
			var clone = eachElement.cloneNode(true);

			// Remove the attribute of the clone
			clone.removeAttribute("ar-foreach");
			
			// If the foreach elements need to be changed later or completely replaced it will need to know, then the framework stores the information.
			if (clone.getAttribute("ar-model")) {
				if (this.refs[propertyName] == null) {
					this.refs[propertyName] = [clone];
				}
				else {
					this.refs[propertyName].push(clone);
				}
			}

			eachElement.parentNode.insertBefore(clone, eachElement.nextSibling);

			var elementsObj = ElementProcessor.getAllChildren(clone);

			// Elements to populate inside foreach.
			this.populateElements(elementsObj, varia[x], as);

			// Then check if the element has another foreach then process those
			var eachElements = ElementProcessor.getAllChildrenWithAttribute(clone, "ar-foreach");
			for (var i = eachElements.length - 1; i >= 0; i--) {
				this.populateForeach(eachElements[i], varia[x], controller);
			}
		}

		eachElement.style.display = "none";
	},
	/* Parent function for populateForeach */
	populateAllForeach: function() {
		var eachElement = document.querySelectorAll("[render-view]")[0];
		var eachElements = ElementProcessor.getAllChildrenWithAttribute(eachElement, "ar-foreach");
		for (var i = eachElements.length - 1; i >= 0; i--) {
			try{
				this.populateForeach(eachElements[i], this.controller, this.controller);
			} catch(err)
			{
				console.log("[Arati ERROR] a variable was undefined when trying to run the foreach loop." + err);
			}
		}
	},
	/*
		Populates all elements inside a view and caches 
		the elements that can later be updated easily by code 
	*/
	populateAllElements: function() {
		this.storeElements();
		this.populate();
		this.populateAllForeach();
		this.registerEvents();
	},
	/* Executes when the view has loaded*/
	load: function() {
		if (this.controller.init != null) {
			var bound = this.populateAllElements.bind(this);
			this.controller.init(bound);
		}
		else {
			this.populateAllElements();
		}
	},
	/* Stores the elements that can be easily updated later by controller/code. */
	storeElements: function() {
		var dict = {}
		var eles = this.viewElement.querySelectorAll("[ar-update]");
		for (var i = eles.length - 1; i >= 0; i--) {
			var att = eles[i].getAttribute("ar-update");
			var di = dict[att];
			if (di != null) {
				dict[att].push({"element": eles[i], "template": eles[i].innerHTML});
			}
			else {
				dict[att] = [{"element": eles[i], "template": eles[i].innerHTML}];
			}
		}
		this.dict = dict;
	},
	/* Registers all arati specific events */
	registerEvents: function() {
		var that = this;

		var onclickElements = this.rootElement.querySelectorAll("[ar-onclick]");
		for (var i = 0; i < onclickElements.length; i++) {
			onclickElements[i].addEventListener("click", this.controller[onclickElements[i].getAttribute("ar-onclick")]);
		}

		var boundElements = this.rootElement.querySelectorAll("[ar-model]");
		for (var i = 0; i < boundElements.length; i++) {
			console.log("Register click event.");
			boundElements[i].addEventListener("change", function(el) {
				that.onModelChanged(el);
			});
		}

		var changedElements = this.rootElement.querySelectorAll("[ar-change]");
		for (var i = 0; i < changedElements.length; i++) {
			console.log("Register click event.");
			changedElements[i].addEventListener("change", function(el) {
				that.onElementChanged(el);
			});
		}
	},
	onElementChanged: function(el) {
		this.controller[el.target.getAttribute("ar-change")]();
	},
	onModelChanged: function(el) {
		this.update(el.target.getAttribute("ar-model"), el.target.value);
	},
	/**
	 * Updates a specific value and lets Arati/controller know about it so it can update the view.
	 * @param {String} name - name of the object
	 * @param {Object} value - the updated object
	 * @return 
	 */
	update: function(name, value) {
		if (value != undefined) {
			//console.log("Update: name = " + name + ", value = " + value);
			this.controller[name] = value;
		}
		for (var i = this.dict[name].length - 1; i >= 0; i--) {
			// If it's updating a list then update it differently.
			if (this.dict[name][i].element.getAttribute("ar-foreach")) {
				/* Do some foreach updating */
				var ele = this.dict[name][i].element;
				// Need to find a way to store the original display style so i can actually reverse back correctly.
				ele.style.display = "block"; // THIS IS A QUICKFIX !!

				this.populateForeach(ele, this.controller, this.controller);
			}
			else {
				var output = Utility.replaceWithVariables(this.dict[name][i].template, this.controller);
				this.dict[name][i].element.innerHTML = output;
			}
		}
	}
}